Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pickle import TRUE\r\nfrom ReadingDataSet import ReadingDataSet\r\nfrom keys import keys\r\nfrom InitializingNodesAndEdges import InitializeNodesAndEdges\r\nfrom nodes_edges_df import nodes_edges_dfs\r\n\r\ndataSet = ReadingDataSet()\r\n# Dictionary containing all dataframes\r\nAll_dfs = dataSet.All_dfs\r\n# print(f\"Df Keys: {All_dfs}\")\r\n\r\nkey = keys(All_dfs)\r\n# Dictionary indicating the column of each table that represents the primary key\r\nAll_pks = key.primaryKeyGetter()\r\nprint(f\"Primary Keys: {All_pks}\")\r\nprint('-------------------------')\r\n# Dictionary indicating the column of each table that represents the foreign key and the referenced table name\r\nAll_fks = key.foreignKeyGetter()\r\nprint(f\"Foreign Keys: {All_fks}\")\r\nprint('-------------------------')\r\n# Dictionary indicating which tables references the table \r\nAll_ref_ins = key.ref_in\r\nprint(f\"Ref In Keys: {All_ref_ins}\")\r\nprint('-------------------------')\r\n\r\ninitializingNodesAndEdges = InitializeNodesAndEdges(All_dfs, All_fks)\r\nnodes = initializingNodesAndEdges.nodes\r\nprint(f\"Nodes: {nodes}\")\r\nprint('-------------------------')\r\nedges = initializingNodesAndEdges.edges\r\nprint(f\"Edges: {edges}\")\r\nprint('-------------------------')\r\nproperties = initializingNodesAndEdges.properties\r\nprint(f\"Properties: {properties}\")\r\nprint('-------------------------')\r\n\r\n\r\n# True to output nodes table and edges table as a normal graph\r\n# False to output nodes table and edges table but edges are nodes\r\ninitialize_nodes_edges_df = nodes_edges_dfs(nodes, edges, properties, All_pks, All_fks, All_ref_ins, All_dfs, True)\r\n\r\nnodesTable = initialize_nodes_edges_df.nodesTable\r\nprint(\"Nodes Table: \")\r\nprint(nodesTable)\r\nprint('-------------------------')\r\n\r\n\r\nedgesTable = initialize_nodes_edges_df.edgesTable\r\nprint(\"Edges Table: \")\r\nprint(edgesTable)\r\nprint('-------------------------')\r\n\r\ninitialize_nodes_edges_df = nodes_edges_dfs(nodes, edges, properties, All_pks, All_fks, All_ref_ins, All_dfs, False)\r\n\r\nnodes_df = initialize_nodes_edges_df.nodes_df_edges_as_nodes\r\nprint(\"Nodes DF: \")\r\nprint(nodes_df)\r\nprint('-------------------------')\r\n\r\n\r\nedges_df = initialize_nodes_edges_df.edges_df_edges_as_nodes\r\nprint(\"Edges DF: \")\r\nprint(edges_df)\r\nprint('-------------------------')\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 4517aa634b59ee3c5ee37a9256a3edad9ec5c81e)
+++ b/main.py	(date 1661693293772)
@@ -3,6 +3,7 @@
 from keys import keys
 from InitializingNodesAndEdges import InitializeNodesAndEdges
 from nodes_edges_df import nodes_edges_dfs
+from Neo4jGraph import Neo4jGraph
 
 dataSet = ReadingDataSet()
 # Dictionary containing all dataframes
@@ -34,7 +35,6 @@
 print(f"Properties: {properties}")
 print('-------------------------')
 
-
 # True to output nodes table and edges table as a normal graph
 # False to output nodes table and edges table but edges are nodes
 initialize_nodes_edges_df = nodes_edges_dfs(nodes, edges, properties, All_pks, All_fks, All_ref_ins, All_dfs, True)
@@ -44,7 +44,6 @@
 print(nodesTable)
 print('-------------------------')
 
-
 edgesTable = initialize_nodes_edges_df.edgesTable
 print("Edges Table: ")
 print(edgesTable)
@@ -57,18 +56,11 @@
 print(nodes_df)
 print('-------------------------')
 
-
 edges_df = initialize_nodes_edges_df.edges_df_edges_as_nodes
 print("Edges DF: ")
 print(edges_df)
 print('-------------------------')
 
-
-
-
-
-
-
-
-
-
+# Testing Graph
+neo4j_agent = Neo4jGraph(nodes_df, edges_df)
+neo4j_agent.draw_graph()
Index: Neo4jGraph.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class Neo4jGraph:\r\n\r\n    def __init__(self, nodes_df, edges_df):\r\n\r\n        self.__DBusername = \"neo4j\"\r\n        self.__DBpassword = \"password\"\r\n        self.__DBuri = \"bolt://localhost:7687\"\r\n\r\n        self.nodes_df = nodes_df\r\n        self.edges_df = edges_df\r\n\r\n        self.__transaction_execution_commands = []\r\n\r\n    def draw_graph(self):\r\n        self.__transaction_execution_commands = []\r\n        self.__add_delete_statement()\r\n        self.__add_nodes_statements()\r\n        self.__add_edges_statemnts()\r\n        self.execute_transactions()\r\n\r\n    def execute_transactions(self):\r\n        from neo4j import GraphDatabase\r\n        data_base_connection = GraphDatabase.driver(uri=\"bolt://localhost:7687\", auth=(\"neo4j\", \"password\"))\r\n        session = data_base_connection.session()\r\n        for command in self.__transaction_execution_commands:\r\n            session.run(command)\r\n\r\n    def __add_delete_statement(self):\r\n        delete_statement = \"match (n) detach delete n\"\r\n        self.__transaction_execution_commands.append(delete_statement)\r\n\r\n    def __add_nodes_statements(self):\r\n        for node_index, node in self.nodes_df.iterrows():\r\n            label = node[\"Label\"].capitalize()\r\n            IDs = node[\"ID\"]\r\n            attributes = node[\"Attributes\"]\r\n            create_statement = self.__node_create_statement(label, node_index, IDs, attributes)\r\n            self.__transaction_execution_commands.append(create_statement)\r\n\r\n    def __node_create_statement(self, label, index, IDs, attributes):\r\n        att = (\", \" + self.__destructure_dict(attributes)) if len(attributes) > 0 else \"\"\r\n        return f\"CREATE (x:{label} {'{'}name: {self.__get_node_name(label, IDs)},index:{index},ID:{IDs} {att} {'}'})\"\r\n\r\n    def __get_node_name(self, label, id):\r\n        node_name = '\\\"' + label.capitalize() + ' ' + str(id) + '\\\"'\r\n        return node_name\r\n\r\n    def __destructure_dict(self, attributes):\r\n        import re\r\n        attributes_string = \"\"\r\n        for key in attributes:\r\n            value = attributes[key]\r\n            if isinstance(value, str):\r\n                value = \"\\\"\" + value + \"\\\"\"\r\n            attributes_string = attributes_string + re.sub(\"[^\\w_]\", '', str(key).replace(\" \", \"_\")) + \":\" + str(\r\n                value) + \",\"\r\n        return attributes_string[:-1]\r\n\r\n    def __add_edges_statemnts(self):\r\n        for i, edge in self.edges_df.iterrows():\r\n            create_relation_statement = self.__relation_create_statement(edge)\r\n            self.__transaction_execution_commands.append(create_relation_statement)\r\n\r\n    def __relation_create_statement(self, edge):\r\n        from_id = edge['From']\r\n        to_id = edge['To']\r\n        from_name = edge['From_Table']\r\n        to_name = edge['To_Table']\r\n        rel_name = edge['Edge_Name']\r\n        weight = edge['Weight']\r\n        match_statement = f\"Match (a:{from_name}),(b:{to_name}) WHERE a.index ={from_id} AND b.index = {to_id} \"\r\n        create_statement = f\"CREATE (a) - [r:{rel_name} {'{ weight: ' + str(weight) + ' }'}]->(b)\"\r\n        create_relation_statement = match_statement + create_statement\r\n        return create_relation_statement\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Neo4jGraph.py b/Neo4jGraph.py
--- a/Neo4jGraph.py	(revision 4517aa634b59ee3c5ee37a9256a3edad9ec5c81e)
+++ b/Neo4jGraph.py	(date 1661693421524)
@@ -13,9 +13,13 @@
 
     def draw_graph(self):
         self.__transaction_execution_commands = []
+        print("Deleting All nodes")
         self.__add_delete_statement()
+        print("Adding new nodes...")
         self.__add_nodes_statements()
+        print("Adding new relations/edges...")
         self.__add_edges_statemnts()
+        print("Executing All commands...")
         self.execute_transactions()
 
     def execute_transactions(self):
Index: nodes_edges_df.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pandas as pd\r\n\r\n\r\nclass nodes_edges_dfs:\r\n\r\n    def __init__(self, nodes, edges, properties, pk, fk, ref_in, All_dfs,edges_as_edges):\r\n        self.nodes = nodes\r\n        self.edges = edges\r\n        self.properties = properties\r\n        self.pk = pk\r\n        self.fk = fk\r\n        self.ref_in = ref_in\r\n        self.All_dfs = All_dfs\r\n        self.nodesTable = pd.DataFrame(columns=['Label', 'ID', 'Attributes'])\r\n        self.edgesTable = pd.DataFrame(columns=['From_Node_ID', 'To_Node_ID', 'order/service'])\r\n\r\n        self.nodes_df_edges_as_nodes = pd.DataFrame(columns=['Label', 'ID', 'Attributes'])\r\n        self.edges_df_edges_as_nodes = pd.DataFrame(columns=['From', 'To', 'From_Table', 'To_Table', 'Weight', 'Edge_Name'])\r\n        self.edges_as_edges = edges_as_edges\r\n\r\n        self.create_nodes_and_edges_df()\r\n\r\n    def create_nodes_and_edges_df(self):\r\n        if(self.edges_as_edges):\r\n            print('TRUEEEE')\r\n            self.__prepare_graph_edges_as_edges()\r\n            return self.nodesTable,self.edgesTable\r\n        else:\r\n            print('FALSEEE')\r\n            self.__prepare_graph_edges_as_nodes()\r\n            return self.nodes_df_edges_as_nodes,self.edges_df_edges_as_nodes\r\n\r\n    def __prepare_graph_edges_as_edges(self):\r\n        self.nodesTable = self.__add_nodes()\r\n        self.edgesTable = self.__add_edges()\r\n\r\n\r\n    # Create nodes table\r\n    def __add_nodes(self):\r\n\r\n        nodesTB = pd.DataFrame(columns=['Label', 'ID', 'Attributes'])\r\n        \r\n        allDfsKeys = list(self.All_dfs.keys())\r\n\r\n        for node in self.nodes:\r\n            dfNumpy =  self.All_dfs[node].to_numpy()\r\n            allDfsKeys.remove(node)\r\n            for row in dfNumpy:\r\n                newRow = [{'Label': node, 'ID': row[0] , 'Attributes': row[1:]}]\r\n                tmp = pd.DataFrame(newRow)\r\n                nodesTB = pd.concat([nodesTB, tmp], ignore_index=True)\r\n        return nodesTB\r\n\r\n    def __convert_prop(self, edge_key, pk_value):\r\n        for referenced_table_name in self.ref_in[edge_key]:\r\n            referenced_table = self.All_dfs[referenced_table_name]\r\n            fk_of_ref_table = self.fk[referenced_table_name]\r\n            for foreign_key in fk_of_ref_table:\r\n                if fk_of_ref_table[foreign_key] == edge_key:\r\n                    # referenced_table[referenced_table[foreign_key]== id]\r\n                    all_occurances_df = referenced_table[referenced_table[foreign_key] == pk_value].drop([foreign_key],\r\n                                                                                                         axis=1)\r\n                    return all_occurances_df.to_dict('records')\r\n\r\n    # Create edges table\r\n    def __add_edges(self):\r\n        edgesTB = pd.DataFrame(columns=['From_Node_ID', 'To_Node_ID', 'order/service'])\r\n        for edge in self.edges:\r\n            df = self.All_dfs[edge]  # df of the cur edge\r\n            for row in range(len(df)):\r\n                label = list(self.fk[edge].keys())\r\n                from_id = self.nodesTable[\r\n                    (self.nodesTable[\"Label\"] == self.fk[edge][label[0]]) & (df.loc[row, label[0]] == self.nodesTable[\"ID\"])]\r\n                from_id = from_id.index[0]\r\n                to_id = self.nodesTable[\r\n                    (self.nodesTable[\"Label\"] == self.fk[edge][label[1]]) & (df.loc[row, label[1]] == self.nodesTable[\"ID\"])]\r\n                to_id = to_id.index[0]\r\n                pk_col = self.pk[edge]\r\n                # primary_key = df[pk_col].iloc[row]\r\n                primary_key = df.loc[row, pk_col]\r\n                att = self.__convert_prop(edge, primary_key)\r\n                newRow = [{'From_Node_ID': from_id, 'To_Node_ID': to_id, 'order/service': att}]\r\n                tmp = pd.DataFrame(newRow)\r\n                edgesTB = pd.concat([edgesTB, tmp], ignore_index=True)\r\n        return edgesTB\r\n\r\n    def __prepare_graph_edges_as_nodes(self):\r\n\r\n        self.__create_nodes_df()\r\n        self.__add_edges_to_edges_df()\r\n        self.__add_properties_to_dfs()\r\n        self.__add_manufacturing_relation_to_dfs()\r\n        self.__add_internal_orders_to_dfs()\r\n        return self.nodes_df_edges_as_nodes, self.edges_df_edges_as_nodes\r\n\r\n    def __create_nodes_df(self):\r\n        for node in self.nodes:\r\n            column_names = list(self.All_dfs[node].columns)  # get column names\r\n            for index, row in self.All_dfs[node].iterrows():\r\n                att = {}\r\n                for i in range(1, len(column_names)):\r\n                    att[column_names[i]] = self.All_dfs[node].iloc[index, i]\r\n                newRow = [{'Label': node, 'ID': self.All_dfs[node].iloc[index, 0], 'Attributes': att}]\r\n                tmp = pd.DataFrame(newRow)\r\n                self.nodes_df_edges_as_nodes = pd.concat([self.nodes_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n    def __add_edges_to_edges_df(self):\r\n        for edge_name in self.edges:\r\n            foreign_keys = list(self.fk[edge_name].keys())\r\n\r\n            from_col = foreign_keys[0]\r\n            from_table_name = self.fk[edge_name][from_col]\r\n\r\n            to_col = foreign_keys[-1]\r\n            to_table_name = self.fk[edge_name][to_col]\r\n\r\n            column_names = list(self.All_dfs[edge_name].columns)  # get column names\r\n            for index, _ in self.All_dfs[edge_name].iterrows():\r\n                att = {}\r\n                from_ref_id, to_ref_id = None, None\r\n\r\n                for i in range(1, len(column_names)):\r\n                    column_name = column_names[i]\r\n\r\n                    if column_name not in foreign_keys:\r\n                        att[column_name] = self.All_dfs[edge_name].iloc[index, i]\r\n\r\n                    else:\r\n                        reference_id = self.All_dfs[edge_name].iloc[index, i]\r\n                        if column_name == from_col:\r\n                            # from_ref_id = from_df[from_df[from_df_pk] == reference_id].index[0]\r\n                            from_ref_id = reference_id\r\n                        else:\r\n                            # to_ref_id = to_df[to_df[to_df_pk] == reference_id].index[0]\r\n                            to_ref_id = reference_id\r\n\r\n                # Adding new entry to node tabel\r\n                newRow = [{'Label': edge_name, 'ID': self.All_dfs[edge_name].iloc[index, 0], 'Attributes': att}]\r\n                tmp = pd.DataFrame(newRow)\r\n                self.nodes_df_edges_as_nodes = pd.concat([self.nodes_df_edges_as_nodes, tmp], ignore_index=True)\r\n                edge_node_index = len(self.nodes_df_edges_as_nodes) - 1\r\n                # print(nodes_df.iloc[len(nodes_df)-1],All_dfs[Edge_name].iloc[index,0] )\r\n                # creating two edges, one from the from_node to the edge node and one from edge node to to_node\r\n                from_node_id = \\\r\n                    self.nodes_df_edges_as_nodes[\r\n                        (self.nodes_df_edges_as_nodes['Label'] == from_table_name) & (self.nodes_df_edges_as_nodes['ID'] == from_ref_id)].index[\r\n                        0]\r\n                to_node_id = \\\r\n                    self.nodes_df_edges_as_nodes[(self.nodes_df_edges_as_nodes['Label'] == to_table_name) & (self.nodes_df_edges_as_nodes['ID'] == to_ref_id)].index[\r\n                        0]\r\n\r\n                # from ---> edge\r\n                new_from_edge_row = [\r\n                    {'From': from_node_id, 'To': edge_node_index, 'From_Table': from_table_name.capitalize(),\r\n                     'To_Table': edge_name.capitalize()\r\n                        , 'Weight': 42, 'Edge_Name': edge_name}]\r\n                tmp = pd.DataFrame(new_from_edge_row)\r\n                self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n                # edge --->to\r\n                new_to_edge_row = [{'From': edge_node_index, 'To': to_node_id, 'From_Table': edge_name.capitalize(),\r\n                                    'To_Table': to_table_name.capitalize()\r\n                                       , 'Weight': 42, 'Edge_Name': edge_name}]\r\n                tmp = pd.DataFrame(new_to_edge_row)\r\n                self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n    def __add_properties_to_dfs(self):\r\n        for property_name in self.properties:\r\n            print(property_name)\r\n\r\n            property_df = self.All_dfs[property_name]\r\n\r\n            foreign_keys = list(self.fk[property_name].keys())\r\n\r\n            fk_col = foreign_keys[0]\r\n            referenced_table_name = self.fk[property_name][fk_col]\r\n\r\n            column_names = list(property_df.columns)  # get column names\r\n\r\n            for index, _ in property_df.iterrows():\r\n                att = {}\r\n                reference_id = None;\r\n\r\n                for i in range(1, len(column_names)):\r\n                    column_name = column_names[i]\r\n\r\n                    if column_name not in foreign_keys:\r\n                        att[column_name] = property_df.iloc[index, i]\r\n\r\n                    else:\r\n                        # capturing foreign key value\r\n                        reference_id = property_df.iloc[index, i]\r\n\r\n                # Adding new entry to node tabel\r\n                newRow = [{'Label': property_name, 'ID': property_df.iloc[index, 0], 'Attributes': att}]\r\n                tmp = pd.DataFrame(newRow)\r\n                self.nodes_df_edges_as_nodes = pd.concat([self.nodes_df_edges_as_nodes, tmp], ignore_index=True)\r\n                property_node_index = len(self.nodes_df_edges_as_nodes) - 1\r\n                # print(nodes_df.iloc[len(nodes_df)-1],property_df.iloc[index,0] )\r\n\r\n                # creating two edges, one from the from_node to the edge node and one from edge node to to_node\r\n                if isinstance(reference_id, list):\r\n                    for list_element_id in reference_id:\r\n                        referenced_node_id = self.nodes_df_edges_as_nodes[(self.nodes_df_edges_as_nodes['Label'] == referenced_table_name) & (\r\n                                self.nodes_df_edges_as_nodes['ID'] == list_element_id)].index[0]\r\n\r\n                        new_property_edge_row = [{'From': referenced_node_id, 'To': property_node_index,\r\n                                                  'From_Table': referenced_table_name.capitalize(),\r\n                                                  'To_Table': property_name.capitalize()\r\n                                                     , 'Weight': 42, 'Edge_Name': \"Related_To\"}]\r\n                        tmp = pd.DataFrame(new_property_edge_row)\r\n                        self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n                else:\r\n                    referenced_node_id = self.nodes_df_edges_as_nodes[(self.nodes_df_edges_as_nodes['Label'] == referenced_table_name) & (\r\n                            self.nodes_df_edges_as_nodes['ID'] == reference_id)].index[0]\r\n\r\n                    new_property_edge_row = [{'From': referenced_node_id, 'To': property_node_index,\r\n                                              'From_Table': referenced_table_name.capitalize(),\r\n                                              'To_Table': property_name.capitalize()\r\n                                                 , 'Weight': 42, 'Edge_Name': \"Related_To\"}]\r\n                    tmp = pd.DataFrame(new_property_edge_row)\r\n                    self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n    def __add_manufacturing_relation_to_dfs(self):\r\n        manufacturing_df = self.All_dfs[\"manufacturing\"]\r\n\r\n        for i, manufacturing_row in manufacturing_df.iterrows():\r\n            factory_id = manufacturing_row[\"Factory_id\"]\r\n            supplier_node_index = self.nodes_df_edges_as_nodes.query(f\"(Label == 'supplier' ) and (ID == {factory_id}) \").index[0]\r\n\r\n            product_id = manufacturing_row[\"Product_id\"]\r\n            product_node_index = self.nodes_df_edges_as_nodes.query(f\"(Label == 'products' ) and (ID == {product_id}) \").index[0]\r\n\r\n            new_edge_row = [\r\n                {'From': supplier_node_index, 'To': product_node_index, 'From_Table': \"supplier\".capitalize(),\r\n                 'To_Table': \"products\".capitalize()\r\n                    , 'Weight': 42, 'Edge_Name': \"Manufactures\"}]\r\n            tmp = pd.DataFrame(new_edge_row)\r\n            self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n    def __add_internal_orders_to_dfs(self):\r\n        ss_internal_orders_df = self.All_dfs[\"ssintorders\"]\r\n        for i, ss_internal_order_row in ss_internal_orders_df.iterrows():\r\n\r\n            att = {}\r\n            for column_name in ss_internal_orders_df:\r\n                if (column_name not in self.fk[\"ssintorders\"].keys() and column_name != self.pk[\"ssintorders\"]):\r\n                    att[column_name] = ss_internal_order_row[column_name]\r\n\r\n            newRow = [{'Label': \"ssintorders\", 'ID': ss_internal_orders_df.iloc[i, 0], 'Attributes': att}]\r\n\r\n            tmp = pd.DataFrame(newRow)\r\n            self.nodes_df_edges_as_nodes = pd.concat([self.nodes_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n            internal_order_index = len(self.nodes_df_edges_as_nodes) - 1\r\n\r\n            internal_shipment_id = ss_internal_order_row[\"IntShip_id\"]\r\n            internal_shipment_node_index = \\\r\n                self.nodes_df_edges_as_nodes.query(f\"(Label == 'ssintship' ) and (ID == {internal_shipment_id}) \").index[0]\r\n\r\n            product_id = ss_internal_order_row[\"prod_id\"]\r\n            product_node_index = self.nodes_df_edges_as_nodes.query(f\"(Label == 'products' ) and (ID == {product_id}) \").index[0]\r\n\r\n            # from ---> edge\r\n            new_from_edge_row = [\r\n                {'From': internal_shipment_node_index, 'To': internal_order_index,\r\n                 'From_Table': \"ssintship\".capitalize(),\r\n                 'To_Table': \"ssintorders\".capitalize()\r\n                    , 'Weight': 42, 'Edge_Name': \"Order\"}]\r\n            tmp = pd.DataFrame(new_from_edge_row)\r\n            self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n            # edge --->to\r\n            new_to_edge_row = [\r\n                {'From': internal_order_index, 'To': product_node_index, 'From_Table': \"ssintorders\".capitalize(),\r\n                 'To_Table': \"products\".capitalize()\r\n                    , 'Weight': 42, 'Edge_Name': \"Orders_Prodcut\"}]\r\n            tmp = pd.DataFrame(new_to_edge_row)\r\n            self.edges_df_edges_as_nodes = pd.concat([self.edges_df_edges_as_nodes, tmp], ignore_index=True)\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/nodes_edges_df.py b/nodes_edges_df.py
--- a/nodes_edges_df.py	(revision 4517aa634b59ee3c5ee37a9256a3edad9ec5c81e)
+++ b/nodes_edges_df.py	(date 1661692731333)
@@ -18,10 +18,10 @@
         self.edges_df_edges_as_nodes = pd.DataFrame(columns=['From', 'To', 'From_Table', 'To_Table', 'Weight', 'Edge_Name'])
         self.edges_as_edges = edges_as_edges
 
-        self.create_nodes_and_edges_df()
+        self.__create_nodes_and_edges_df()
 
-    def create_nodes_and_edges_df(self):
-        if(self.edges_as_edges):
+    def __create_nodes_and_edges_df(self):
+        if self.edges_as_edges:
             print('TRUEEEE')
             self.__prepare_graph_edges_as_edges()
             return self.nodesTable,self.edgesTable
